# 백준 1번 (유성)
- - -
```
#include <iostream>
#include <string.h>

using namespace std;

int main()	{
	int col, row, r, c, high = -1, min = -1;
	scanf("%d %d", &col, &row);
	char data[col][row+1];
	for(c=0; c<col; c++)
		cin >> data[c];
		
	for(c=0; c<col; c++)
		for(r=0; r<row; r++)
			if(data[c][r] == 'X')
				high = c;			// 가장 지면과 가까운 유성의 높이를 high에 저장
		
	for(r=0; r<row; r++)	{
		int distance = 0, s_pos = 0, e_pos = 0;
		bool start = false;
		for(c=0; c<col; c++)	{
			if(start == false && data[c][r] == 'X' && data[c+1][r] == '.')	{
				start = true;
				s_pos = c;			// 유성위치
			}
			else if(start == true && data[c][r] == 'X' && data[c+1][r] == '.')	{
				s_pos = c;			// 이건 유성의 모양에 따라 생기는 반례를 막기위함..
			}
			else if(start == true && data[c][r] == '#')	{
				e_pos = c;			// 지면위치
				distance = e_pos-s_pos-1;	// 유성과 지면의 거리를 distance에 저장
				break;
			}
		}
		if(start == true)	{
			if(min == -1)	min = distance;
			else
				if(min > distance)	min = distance;		// 최소거리를 min에 저장
		}
	}
	if(min != -1 && high != -1)	{
		for(c=high; c>=0; c--)	{
			for(r=0; r<row; r++)	{
				if(data[c][r] == 'X')	{
					if(c+min < col)
						data[c+min][r] = 'X';		// 최소거리만큼 유성을 옮기는 과정
					data[c][r] = '.';
				}
			}
		}
	}
	
	for(c=0; c<col; c++)	{
			for(r=0; r<row; r++)
				cout << data[c][r];
			cout << endl;
	}
	
	return 0; 
}
```
# 백준 2번 (문자열 잘라내기) - 엄두도 안남 두손두발 다듬
- - -
```
#include <iostream>
#include <string.h>

using namespace std;

int main()	{
	int col, row, r, c;
	scanf("%d %d", &col, &row);
	char data[col][row+1];		// 행 문자열 선언(처음 입력받는 문자열) 
	char result[row][col+1];	// 열 문자열 선언 
	for(r=0; r<row; r++)	// 열 문자열 초기화 
		strcpy(result[r], "");
		
	for(c=0; c<col; c++)
		cin >> data[c];
	
	for(r=0; r<row; r++)	{
		for(c=0; c<col; c++)
			result[r][c] = data[c][r];	// 각 행의 첫번째 열의 문자를 result문자열에 대입 
		result[r][col] = '\0';
	}
	
	for(r=0; r<row; r++)	{
	
  // 여기서 중복검사를 해야하는데 어떻게 짜야할지 모르겠음..

	}
	
	return 0;
}
```
