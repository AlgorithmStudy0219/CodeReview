# 백준 2번 (좋은 단어)
- - -
```
#include <iostream>
#include <string>
#include <stack>

using namespace std;

int main()	{
	int n,i,j, cnt = 0;
	cin >> n;
	string data[n];
	for(i=0; i<n; i++)	{
		cin >> data[i];
		stack<char> check;
		int size = data[i].length();
		for(j=0; j<size; j++)	{
			if(j==0)	check.push(data[i][j]);       // 처음엔 그냥 stack에 집어넣음
			else	{
				if(!check.empty())	
					if(check.top() == data[i][j])	check.pop();  // 이전 문자가 저장된 stack의 top과 현재 문자를 비교해서 같다면 이전 문자를 pop해준다. 현재문자도 저장 X
					else	check.push(data[i][j]);               // 아니라면 그냥 push
				else	check.push(data[i][j]);                 // 스택이 비어있다면 그냥 push
			}
		}
		if(check.empty())	cnt++;                          // 위의 과정이 끝나고 stack이 비어있다면 모두 짝이 맞으므로 cnt값 ++
	}
	cout << cnt << endl;
	return 0;
}
```
# 프로그래머스 1번 (타겟 넘버)
- - -
```
#include <string>
#include <vector>

using namespace std;

int cnt;

void dfs(int n, int target, vector<int> numbers) {
    if(n == target && numbers.empty()) cnt++;		// numbers벡터가 비어있고(모든 숫자 사용 끝) 현재 숫자가 타겟넘버에 도달했다면 cnt증감
    else if(!numbers.empty())   {			// 아직 숫자들을 다 사용하지 못했다면
        int number = numbers.front();			// 맨 앞에 숫자 nuber변수에 저장하고
        numbers.erase(numbers.begin());			// 벡터에선 지움
        dfs(n+number, target, numbers);			// 재귀함수로 DFS해준다.
        dfs(n-number, target, numbers);
    }
}

int solution(vector<int> numbers, int target) {
    int answer = 0;
    dfs(0, target, numbers);
    answer = cnt;
    return answer;
}
```
