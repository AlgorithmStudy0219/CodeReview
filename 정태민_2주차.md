# 백준 1번 (IOIOI)
- - -
```
#include <iostream>
#include <string>

using namespace std;

int main() {
    int n, len, count = 0;
    bool fail = false;
    string s;
    cin >> n >> len >> s;
     
    int p_len = (2*n)+1;  // P문자열의 길이
    int scope = p_len;    // 탐색할 범위
    int i = 0;
    while(i+scope<len)	{ // 탐색범위가 전체길이를 벗어나지 않도록 반복
    	if(s[i] == 'I') {   // 첫 문자가 I인 경우 탐색시작
    		int j;
	        for(j=i+1; j<i+scope; j++) {  // scope변수의 범위만큼 탐색
	            if(s[j-1] == s[j]) {      // 같은 문자가 나오면 패턴에 부합하지 않으므로
			i = j;                // 그 바로 다음부터 다시 탐색하기위해 i에 j를 대입
			fail = true;          // fail변수를 true
	                scope = p_len;        // 탐색범위는 p_len으로 설정
	                break;
	            }
	        }
	        if(fail == false)    {		    // 패턴에 맞는 문자열을 발견했을 경우 (for문이 break없이 다 수행된 경우)
	        	i=j-1;                      // 역시 그 바로 다음부터 탐색하기위해 i에 j-1를 대입 (for문이 끝나면 j값이 1 더 커져있으므로 1을 빼줌)
	        	scope = 3;                  // 패턴에 맞는 문자열 뒤에 2개에 문자열만 다시 "OI"가 나온다면 또 하나의 패턴에 부합하는 문자열이다. 따라서 범위는 3으로만 설정
			count++;
		}
	        else	fail = false;
	}
	else	i++;
    }
    cout << count << endl;
	return 0;
}
```
# 백준 2번 (한국이 그리울 땐 서버에 접속하지)
- - -
```
#include <iostream>
#include <string>
#include <string.h>

using namespace std;

int main() {
	int n, s_len, e_len, i, j = 0;
	string p;
	bool fail, s_to_e = false;
	char start[100];
	char end[100];
	cin >> n >> p;
	string s[n];
	for(i=0; i<n; i++)
		cin >> s[i];
	
	for(i=0; i<p.length(); i++)	{	// '*'를 기준으로 앞의 문자열과 뒤의 문자열을 start, end배열에 대입
		if(p[i] == '*') {		// '*'를 만나면
			start[i] = '\0';	// 끝에 널문자를 붙혀주고
			s_to_e = true;		// s_to_e변수를 true로 설정 (뒤에 문자열 대입시작)
			continue;		// 건너뛴다.
		}
		if(s_to_e == false)		start[i] = p[i];	// start배열의 앞에부터 p배열을 순차적으로 대입 
		else if(s_to_e == true)	{	// s_to_e변수가 true이면
			end[j] = p[i];		// end배열의 앞에부터 p배열을 순차적으로 대입
			j++;
		}
	}
	end[j] = '\0';				// 끝에 널문자를 붙혀준다.
	s_len = strlen(start);			// start배열의 길이
	e_len = strlen(end);			// end배열의 길이
	
	for(i=0; i<n; i++) {
		int length = s[i].length();
		fail = false;
		for(j=0; j<s_len; j++) {				// 입력받은 문자열과 패턴의 start문자열을 비교
			if(s[i][j] != start[j]) {			// 다르다면
				fail = true;				// fail변수를 true로 설정
				cout << "NE" << endl;
				break;
			}
			s[i][j] = '\0';					// 탐색이 끝난 문자는 널문자로 변경 (중복방지)
		}
		if(fail == true)	continue;			// 앞에 패턴이 틀렸다면 뒤에는 할 필요가 없다.
		for(j=0; j<e_len; j++)	{				// 입력받은 문자열의 뒷부분과 end문자열을 비교
			if(s[i][length-j-1] != end[e_len-j-1]) {	// 다르다면
				fail = true;				// fail변수를 true로 설정
				cout << "NE" << endl;
				break;
			}
			s[i][length-j-1] = '\0';
		}
		if(fail == false) cout << "DA" << endl;
	}
	return 0;
}
```
# 백준 3번 (이친수)
- - -
```
#include <iostream>

using namespace std;

int main()	{
	int n;
	long long P[90][2];				// 작은 문제의 해를 저장해놓을 2차원 배열 P
	P[0][0] = 0;					// 0으로 시작하는 길이 1의 이친수는 없으므로 0개
	P[0][1] = 1;					// 1로 시작하는 길의 1의 이친수는 '1'하나이므로 1개
	
	cin >> n;
	
	for(int i=1; i<n; i++)	{
		P[i][0] = P[i-1][0] + P[i-1][1];	// 길이 i+1의 0으로 끝나는 이친수는 i의 길이의 0으로 끝나는 이친수의 갯수와 i의 길이의 1로 끝나는 이친수의 갯수의 합 
		P[i][1] = P[i-1][0];			// 길의 i+1의 1로 끝나는 이친수는 i의 길이의 0으로 끝나는 이친수의 갯수와 같다.
	}
	cout << P[n-1][0] + P[n-1][1] << endl;
	return 0;	
}
```
