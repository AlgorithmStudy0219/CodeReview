# 백준 1번 (IOIOI)
- - -
```
#include <iostream>
#include <string>

using namespace std;

int main() {
    int n, len, count = 0;
    bool fail = false;
    string s;
    cin >> n >> len >> s;
     
    int p_len = (2*n)+1;  // P문자열의 길이
    int scope = p_len;    // 탐색할 범위
    int i = 0;
    while(i+scope<len)	{ // 탐색범위가 전체길이를 벗어나지 않도록 반복
    	if(s[i] == 'I') {   // 첫 문자가 I인 경우 탐색시작
    		int j;
	        for(j=i+1; j<i+scope; j++) {  // scope변수의 범위만큼 탐색
	            if(s[j-1] == s[j]) {      // 같은 문자가 나오면 패턴에 부합하지 않으므로
					        i = j;                // 그 바로 다음부터 다시 탐색하기위해 i에 j를 대입
					        fail = true;          // fail변수를 true
	                scope = p_len;        // 탐색범위는 p_len으로 설정
	                break;
	            }
	        }
	        if(fail == false)    {        // 패턴에 맞는 문자열을 발견했을 경우 (for문이 break없이 다 수행된 경우)
	        	i=j-1;                      // 역시 그 바로 다음부터 탐색하기위해 i에 j-1를 대입 (for문이 끝나면 j값이 1 더 커져있으므로 1을 빼줌)
	        	scope = 3;                  // 패턴에 맞는 문자열 뒤에 2개에 문자열만 다시 "OI"가 나온다면 또 하나의 패턴에 부합하는 문자열이다. 따라서 범위는 3으로만 설정
				    count++;
			    }
	        else	fail = false;
		}
		else	i++;
    }
    cout << count << endl;
	return 0;
}
```
# 백준 2번 (한국이 그리울 땐 서버에 접속하지)
- - -
```

```
# 백준 3번 (이친수)
- - -
```
#include <iostream>
#include <string>
#include <string.h>

using namespace std;

int main() {
	int n, s_len, e_len, i, j = 0;
	string p;
	bool fail, s_to_e = false;
	char start[100];
	char end[100];
	cin >> n >> p;
	string s[n];
	for(i=0; i<n; i++)
		  cin >> s[i];
	
	for(i=0; i<p.length(); i++)	{     // p배열에서 '*'를 기준으로 앞과 뒤의 문자열을 start배열과 end배열에 저장하는 for문
	    if(p[i] == '*') {
			    start[i] = '\0';
			    s_to_e = true;
			    continue;
		  }
		  if(s_to_e == false)		start[i] = p[i];
		  else if(s_to_e == true)	{
			    end[j] = p[i];
			    j++;
		  }
	}
	end[j] = '\0';
	s_len = strlen(start);            // s_len에는 start배열의 길이 대입
	e_len = strlen(end);              // e_len에는 end배열의 길이 대입
	
	for(i=0; i<n; i++) {
		  int length = s[i].length();
		  fail = false;
		  for(j=0; j<s_len; j++) {
			    if(s[i][j] != start[j]) {
				      fail = true;
				      cout << "NE" << endl;
				      break;
			    }
			    s[i][j] = '\0';
		  }
		  if(fail == true)	continue;
		  for(j=0; j<e_len; j++)	{
			    if(s[i][length-j-1] != end[e_len-j-1]) {
				      fail = true;
				      cout << "NE" << endl;
				      break;
			    }
			    s[i][length-j-1] = '\0';
		  }
		  if(fail == false) cout << "DA" << endl;
	}
	return 0;
}
```
